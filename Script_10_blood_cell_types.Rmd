---
title: "Markdown"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Setup
```{r}
#Set working directory.
setwd("/mnt/virdir/Backup/tjonkman/epigenetic-clocks/")

#set library path.
.libPaths("/mnt/virdir/Backup/tjonkman/Rlibs")

#Load all necessary libraries.
library(SummarizedExperiment)
library(DESeq2)
library(xlsx)
library(BiocParallel)
library(ggplot2)
library(RColorBrewer)
library(reshape2)
library(viridis)

register(MulticoreParam(4))
```

RNA-seq data generated by Monaco et al.: "RNA-Seq Signatures Normalized by mRNA Abundance Allow Absolute Deconvolution of Human Immune Cell Types."
Article: https://www.sciencedirect.com/science/article/pii/S2211124719300592
GEO: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE107011

#Prepare data.
```{r}
#Load monaco's RNA-seq data generated in sorted blood cell types.
load("Input/Input_10a_monaco_RNAseq.RData")

#Load in the trans-genes found in the TWAS.
load("Output/Output_09a_significant_associations_in_trans.RData")
# load("Output/Output_09a.2_all_associations_in_trans.RData")
# sig.associations <- all.associations
# load("Output/Output_09a.3_all_associations_in_cis.RData")
# sig.associations <- sig.cis
twas.genes <- rownames(sig.associations)
head(twas.genes)
length(twas.genes)

#Calculate the median expression of each gene in each cell type (across the 4 donors).
gene.medians <- sapply(1:length(levels(monaco.ss$group)), function(i){
  rowMedians(monaco.counts[,monaco.ss$group == levels(monaco.ss$group)[i]])
})
dimnames(gene.medians) <- list(rownames(monaco.counts), levels(monaco.ss$group))
head(gene.medians)

#Prepare a dataframe containing normalized gene counts, where the maximum expression across all samples per gene is set to 1.
idx <- na.omit(match(twas.genes, rownames(gene.medians)))
monaco.data <- as.data.frame(t(gene.medians[idx,]))
monaco.norm <- as.data.frame(apply(
  monaco.data, 2, function(x){
    (x - min(x, na.rm = F)) / max((x - min(x, na.rm = F)), na.rm = F)
    }))
monaco.norm[1:10,(ncol(monaco.norm)-5):ncol(monaco.norm)]

#Cluster the genes for plotting.
expr.dist <- as.dist(dist(t(monaco.norm)))
expr.dist[is.na(expr.dist)] <- 0
expr.dist[is.nan(expr.dist)] <- 0
sum(is.infinite(expr.dist))  # THIS SHOULD BE 0
expr.cl <- hclust(expr.dist)
```

#Find the cell type with the highest expression for each gene, them perform a binomial test to check whether the distribution is different than expected due to chance.
```{r}
#Per gene, find the cell type with the highest expression. If there are ties (very unlikely), select the first celltype.
max.table <- sort(table(unlist(
  apply(monaco.norm, 2, function(x){
    names(which(x == max(x)))[1]
    })
  )), decreasing = T)
max.table
sum(max.table)

#Perform a binomial test to check whether the number of genes which are the highest in each cell type is more than expected due to chance.
fit <- sapply(1:length(max.table), function(i){
  binom.test(max.table[i], sum(max.table), p = (1/nrow(monaco.norm)), alternative = c("greater"), conf.level = 0.95)$p.value
})

#Print the p-value for each cell type, and whether each cell type is significant or not.
fit
fit<0.05
```

#Add a boxplot figure which shows the expression of all TWAS-genes in different cell types. Should be high in T-cells.
```{r}
#Put the data in a format which ggplot understands.
monaco.boxplot <- monaco.norm
monaco.boxplot$cell.type <- monaco.ss[match(rownames(monaco.boxplot), monaco.ss$group),"group"]
monaco.boxplot$cell.type.long <- monaco.ss[match(rownames(monaco.boxplot), monaco.ss$group),"group_long"]
monaco.boxplot$category <- monaco.ss[match(rownames(monaco.boxplot), monaco.ss$group),"group10"]
monaco.boxplot[1:10,(ncol(monaco.boxplot)-5):ncol(monaco.boxplot)]

monaco.boxplot.melt <- melt(monaco.boxplot, id.vars = c("cell.type", "cell.type.long", "category"), variable.name = "ensembl", value.name = "expression")
load("/mnt/virdir/Backup/tjonkman/jrp2-thomas-jonkman/Output/Output_01a_ensembl_genes.RData")
monaco.boxplot.melt$symbol <- GeneEns$symbol[monaco.boxplot.melt$ensembl]
head(monaco.boxplot.melt)

#Plot the normalized expression values of a single gene, grouped by cell type.
ggplot(data = monaco.boxplot.melt, aes(x = cell.type, y = expression, color = category)) +  
  geom_boxplot(outlier.alpha = 0) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  ggtitle("Expression of trans-genes in blood cell types") +
  xlab("Cell type") +
  ylab("Normalized expression") +
  facet_grid(.~category, scales = "free_x", space = "free_x") +
  theme(strip.text.x = element_blank()) +
  scale_color_manual(values = c("#ff3333", "#ffaa00", "#33dd33", "#3377ff", "#3300dd", "#aa33ff", "#ff33ff"))
ggsave(filename = "Output/Plot_10a.1_monaco_boxplot.png", width = 10, height = 5)
```

#Plot the normalized expression (between 0-1) of all genes across cell types in a heatmap.
```{r}
#Select genes in the order of the clustering.
monaco.cl <- hclust(dist(monaco.norm))
monaco.heatmap <- monaco.norm[monaco.cl$order , expr.cl$labels[expr.cl$order]]

#Add vectors designating cell type and rough cell type categories.
monaco.heatmap$cell.type <- monaco.ss[match(rownames(monaco.heatmap), monaco.ss$group),"group"]
monaco.heatmap$cell.type.long <- monaco.ss[match(rownames(monaco.heatmap), monaco.ss$group),"group_long"]
monaco.heatmap$category <- monaco.ss[match(rownames(monaco.heatmap), monaco.ss$group),"group10"]
monaco.heatmap$category2 <- cutree(monaco.cl, k=4)[rownames(monaco.heatmap)]
monaco.heatmap[1:10,(ncol(monaco.heatmap)-5):ncol(monaco.heatmap)]

#Put the data in a format which ggplot understands.
monaco.heatmap.melt <- melt(monaco.heatmap, id.vars = c("cell.type", "cell.type.long", "category", "category2"), variable.name = "ensembl", value.name = "expression")
head(monaco.heatmap.melt)

#Add gene symbols to the data.
load("/mnt/virdir/Backup/tjonkman/jrp2-thomas-jonkman/Output/Output_01a_ensembl_genes.RData")
monaco.heatmap.melt$symbol <- GeneEns[as.character(monaco.heatmap.melt$ensembl)]$symbol
monaco.heatmap.melt$symbol <- factor(monaco.heatmap.melt$symbol, levels = unique(monaco.heatmap.melt$symbol))

#Change the factor levels to the format which will be plotted.
levels(monaco.heatmap.melt$category) <- gsub("T cells", "T-cells", levels(monaco.heatmap.melt$category))
levels(monaco.heatmap.melt$category) <- gsub("B cells", "B-cells", levels(monaco.heatmap.melt$category))
levels(monaco.heatmap.melt$category) <- gsub(" ", "\n", levels(monaco.heatmap.melt$category))
monaco.heatmap.melt$cell.type <- factor(monaco.heatmap.melt$cell.type)
monaco.heatmap.melt$cell.type.long <- factor(monaco.heatmap.melt$cell.type.long, levels = unique(monaco.heatmap.melt$cell.type.long))

#Round the expression values down to the nearest 0.1 value, to reduce plotting noise.
monaco.heatmap.melt$expression <- floor(monaco.heatmap.melt$expression*10)/10
colnames(monaco.heatmap.melt)[which(colnames(monaco.heatmap.melt) == "expression")] <- "Normalized\nExpression"

head(monaco.heatmap.melt)
str(monaco.heatmap.melt)

#Plot heatmap.
ggplot(data = monaco.heatmap.melt, aes(x = cell.type.long, y = symbol, fill = `Normalized\nExpression`)) +  
  geom_tile() + 
  theme(axis.title = element_text(size = 20),
        axis.text.x = element_text(size = 16, angle = 40, hjust = 1, color = "black"), axis.text.y = element_text(size = 1.5, colour = "black"), axis.ticks.y = element_blank(),
        strip.text = element_text(size = 16), legend.title=element_text(size = 16), legend.text = element_text(size = 16)) +
  scale_fill_viridis() +
  ggtitle("") +
  xlab("Cell type") +
  ylab("Gene") +
  theme(plot.margin = unit(c(0.1, 0.1, 0.1, 3), "cm")) +
  facet_grid(cols = vars(category2), scales = "free", space = "free")

ggsave(filename = "Output/Plot_10a.2_monaco_heatmap.png", width = 12, height = 9, dpi = 600)
```

#Prepare a matrix of DNA-methylation values in blood cell types, compiled from 2 studies from the EWAS Datahub (https://bigd.big.ac.cn/ewas/datahub/index).
```{r}
load("Input/Input_10b_EWAS_DataHub_DNAm.RData")
# load("test/edh.data.expanded.RData")
# edh.betas <- round(edh.betas, 3)
head(edh.betas)
head(edh.ss)

#Calculate the median methylation of each clock CpG in each of the unique cell types present in the blueprint-data.
cpg.medians <- sapply(1:length(levels(edh.ss$cell.type)), function(i){
  rowMedians(
    edh.betas[,edh.ss$cell.type == levels(edh.ss$cell.type)[i]]
             , na.rm = T)
})
dimnames(cpg.medians) <- list(rownames(edh.betas), levels(edh.ss$cell.type))

#Remove the CpGs which have 100% missing data.
idx <- apply(cpg.medians, 1, function(x){length(which(is.na(x)))}) == ncol(cpg.medians)
cpg.medians <- cpg.medians[!idx,]

#Select the CpGs which were found in the TWAS.
cpg.medians <- cpg.medians[rownames(cpg.medians) %in% colnames(sig.associations),]

dim(cpg.medians)
cpg.medians[1:10,]

#Per CpG, normalize the methylation values so that the min is set top 0 and the max is set to 1.
cpg.norm <- as.data.frame(t(apply(
  cpg.medians, 1, function(x){
    (x - min(x, na.rm = T)) / max((x - min(x, na.rm = T)), na.rm = T)
    })))
cpg.norm[1:10,]

#Remove the CpGs which have 100% missing data.
idx <- apply(cpg.norm, 1, function(x){length(which(is.na(x)))}) == ncol(cpg.norm)
cpg.norm <- cpg.norm[!idx,]
dim(cpg.norm)

#Cluster the CpGs.
test <- as.matrix(dist(cpg.norm))
idx <- apply(test, 1, function(x){any(is.na(x))})
cpg.norm <- cpg.norm[!idx,]

meth.cl <- hclust(dist(cpg.norm))

#Put the data in a format which ggplot understands.
# edh.heatmap.data <- as.data.frame(t(cpg.medians))
edh.heatmap.data <- as.data.frame(t(cpg.norm))

edh.heatmap.data$cell.type <- factor(x = rownames(edh.heatmap.data), levels = rev(levels(edh.ss$cell.type)))
edh.heatmap.data$category <- factor(x = c("CD4 T-cells", "CD4 T-cells", "CD8 T-cells", "CD8 T-cells", "NK-cells", "NK-cells"), levels = levels(edh.ss$category))
edh.heatmap.data[1:6,(ncol(edh.heatmap.data)-5):ncol(edh.heatmap.data)]

edh.heatmap.melt <- melt(edh.heatmap.data, id.vars = c("cell.type", "category"), variable.name = "CpG", value.name = "Methylation")
edh.heatmap.melt$CpG <- factor(edh.heatmap.melt$CpG, levels = meth.cl$labels[meth.cl$order])
head(edh.heatmap.melt)
dim(edh.heatmap.melt)

ggplot(data = edh.heatmap.melt, aes(x = CpG, y = cell.type, fill = Methylation)) +  
  geom_tile() + 
  theme(strip.text.y = element_text(angle = 0, size = 8), 
        axis.text.x = element_text(size = 0, angle = 45, hjust = 1), axis.text.y = element_text(size = 16, color = "black", hjust = 0),
        axis.ticks.x = element_blank(),
        legend.position="bottom", legend.title = element_blank(), legend.text = element_text(size = 10)) +
  # scale_y_discrete(limits = rev(levels(edh.heatmap.melt$cell.type))) +
  scale_fill_viridis() +
  ggtitle("Methylation of clock-CpGs in blood cell types") +
  xlab("CpG") +
  ylab("") +
  facet_grid(rows = vars(category), scales = "free", space = "free", switch = "y") + 
  scale_y_discrete(position = "right")

ggsave(filename = "Output/Plot_10b_edh_heatmap.png", width = 8, height = 3, dpi = 300)
```

#Draw the TWAS-association heatmap, with two sidebars, the first containing normalized expression of each gene in Monaco's cell types and the second normalized methylation of each clock CpG in the EDH cell types.
```{r}
#Prepare the clustering of the TWAS-associations.
sig.associations[1:5,1:5]
dim(sig.associations)

gene.cl <- hclust(dist(sig.associations), method = "complete")
cpg.cl <- hclust(dist(t(sig.associations)), method = "complete")

#Define color palette and breaks of the heatmap.
my.palette <- colorRampPalette(c("#0000cc", "#0000ff", "#ffffff", "#ff0000", "#cc0000"))(n = 400)
my.breaks <- seq(-12, 12, length=401)

table(rownames(sig.associations) %in% rownames(monaco.counts))

#Calculate the normalized expression of all genes from the sig.associations object in monaco's data. Fill in a NA for missing genes.
sig.norm <- t(monaco.norm)
sig.norm <- sig.norm[match(rownames(sig.associations), rownames(sig.norm)),]
colnames(sig.norm) <- levels(monaco.ss$group_long)
head(sig.norm)

#Create color matrix for the heatmap's row sidebar (low = blue, high = yellow, NA = grey).
row.values <- as.data.frame(apply(sig.norm, 2, function(x){
  as.numeric(cut(x, breaks = seq(0, 1.0, 0.1), labels = seq(0, 0.9, 0.1), include.lowest = T))
}))
head(row.values)

sidebar.palette <- viridis(10)
monaco.sidebar <- apply(row.values, 2, function(x){
  sidebar.palette[x]
})
rownames(monaco.sidebar) <- rownames(sig.associations)
monaco.sidebar[which(is.na(monaco.sidebar))] <- "#aaaaaa"
monaco.sidebar <- t(monaco.sidebar)
head(monaco.sidebar)

#Now do the same for the methylation of clock CpGs in the EDH-data.
sig.medians <- cpg.norm[match(colnames(sig.associations), rownames(cpg.norm)),]
colnames(sig.medians) <- c("Naive CD4 T cells", "Memory CD4 T cells", "Naive CD8 T cells", "Effector CD8 T cells", "Canonical NK-cells", "Adaptive NK-cells")
head(sig.medians)
dim(sig.medians)

column.values <- as.data.frame(apply(sig.medians, 2, function(x){
  as.numeric(cut(x, breaks = seq(0, 1.0, 0.1), labels = seq(0, 0.9, 0.1), include.lowest = T))
}))
head(column.values)

edh.sidebar <- apply(column.values, 2, function(x){
  sidebar.palette[x]
})
rownames(edh.sidebar) <- colnames(sig.associations)
edh.sidebar[which(is.na(edh.sidebar))] <- "#aaaaaa"
edh.sidebar <- edh.sidebar[,6:1]
head(edh.sidebar)

#Insert white spaces between categories to make the figure easier to read.
monaco.sidebar <- rbind(monaco.sidebar[1:2,], "#FFFFFFFF", monaco.sidebar[3:6,], "#FFFFFFFF", monaco.sidebar[7:11,], "#FFFFFFFF", monaco.sidebar[12:17,])
monaco.sidebar[,1:5]

edh.sidebar <- cbind(edh.sidebar[,1:2], "#FFFFFFFF", edh.sidebar[,3:4], "#FFFFFFFF", edh.sidebar[,5:6])
edh.sidebar[1:5,]

#Draw heatmap.
load("Input/Input_05a_heatmap_function.RData")

png(file = "Output/Plot_10c_super_heatmap.png", width = 7, height = 6, unit = "in", res = 600)
heatmap.3(sig.associations, Rowv=as.dendrogram(gene.cl), Colv=rev(as.dendrogram(cpg.cl)), col = my.palette, breaks = my.breaks, margins = c(12, 0), trace = "none", density.info = "none", dendrogram = "none", 
          key = F, keysize = 0.1, cexRow = 0.2, cexCol = 1, 
          RowSideColors = monaco.sidebar,
          ColSideColors = edh.sidebar,
          RowSideColorsSize = 1.5*nrow(monaco.sidebar), ColSideColorsSize = 0.75*ncol(edh.sidebar),
          symkey = F, KeyValueName="t-statistic", labCol=NA, labRow=NA, na.color = "#ffffff")
dev.off()
```

#Use a series of t-tests to compare each cluster across 2 cell type categories.
```{r}
#Prepare two clusters of sig.associations' genes and cpgs. Select only the genes and CpGs which are present in the external data.
gene.clusters <- cutree(gene.cl, k = 2)
gene.clusters <- gene.clusters[na.omit(match(colnames(monaco.norm), names(gene.clusters)))]
clA <- names(gene.clusters[gene.clusters == 2]) #This is the top gene cluster in the heatmap, which is high in naive cells.
clB <- names(gene.clusters[gene.clusters == 1]) #This is the bottom gene cluster in the heatmap, which is high in naive cells.

cpg.clusters <- cutree(cpg.cl, k = 2)
cpg.clusters <- cpg.clusters[na.omit(match(rownames(cpg.norm), names(cpg.clusters)))]
cl1 <- names(cpg.clusters[cpg.clusters == 2]) #This is the left cpg cluster in the heatmap, which is high in naive cells.
cl2 <- names(cpg.clusters[cpg.clusters == 1]) #This is the right cpg cluster in the heatmap, which is high in effector cells.

#Select the subset of genes and CpGs in the external data which also overlap with the TWAS data (sig.associations).
counts.subset <- monaco.counts[na.omit(match(rownames(sig.associations), rownames(monaco.counts))) , ]
head(counts.subset)
dim(counts.subset)

meth.subset <- edh.betas[na.omit(match(colnames(sig.associations), rownames(edh.betas))) , ]
head(meth.subset)
dim(meth.subset)

#Create normalized matrices of the external RNA-seq and DNAm-data. Per gene/CpG, normalize the values so that their range over all cell types becomes 0 to 1.
#Note: this is done by taking the values of each gene/CpG, subtracting the minimum value for that gene/CpG, then dividing by (max of the gene/CpG)/(min of the gene/CpG).
counts.norm <- t(apply(counts.subset, 1, function(x){
  (x - min(x, na.rm = F)) / max((x - min(x, na.rm = F)), na.rm = F)
}))
counts.norm[1:5,1:5]
dim(counts.norm)

meth.norm <- t(apply(meth.subset, 1, function(x){
  (x - min(x, na.rm = T)) / max((x - min(x, na.rm = T)), na.rm = T)
}))
meth.norm[1:5,1:5]
dim(meth.norm)

#For the external gene expression data, select only the samples measured in naive and effector cell types.
monaco.cell.types <- c("Naive CD4 T cells", "Naive CD8 T cells", 
         "Terminal effector CD4 T cells", "Effector memory CD8 T cells", "Terminal effector CD8 T cells", "Natural killer cells")

ss.subset <- monaco.ss[monaco.ss$group_long %in% monaco.cell.types,]
ss.subset$activation.state <- c(rep("Naive", 8), rep("Effector", 14))
ss.subset$activation.state <- factor(ss.subset$activation.state, levels = unique(ss.subset$activation.state))
ss.subset

counts.norm <- counts.norm[na.omit(match(rownames(sig.associations), rownames(counts.norm))) , rownames(ss.subset)]
head(counts.norm)
dim(counts.norm)

#For the DNAm-data, add the naive-effector information.
levels(edh.ss$cell.type) <- c("Naive CD4 T-cells", "Memory CD4 T-cells", "Naive CD8 T-cells", "Effector CD8 T-cells", "Canonical NK-cells", "Adaptive NK-cells")
edh.ss$activation.state <- factor(NA, levels = c("Naive", "Effector"))
edh.ss$activation.state[c(grep("Naive", edh.ss$cell.type), grep("Canonical", edh.ss$cell.type))] <- "Naive"
edh.ss$activation.state[c(grep("Memory", edh.ss$cell.type), grep("Effector", edh.ss$cell.type), grep("Adaptive", edh.ss$cell.type))] <- "Effector"

edh.ss
head(meth.norm)

#Genes (all naive cell types vs. all effector cell types): 
  #cluster A.
  t.test(
    rowMedians(counts.norm[clA, ss.subset$activation.state == "Naive"]), 
    rowMedians(counts.norm[clA, ss.subset$activation.state == "Effector"])
    )
  #cluster B.
  t.test(
    rowMedians(counts.norm[clB, ss.subset$activation.state == "Naive"]),
    rowMedians(counts.norm[clB, ss.subset$activation.state == "Effector"])
    )

#CpGs (naive CD4 vs memory CD4):
  #cluster 1.
  t.test(
    rowMedians(meth.norm[cl1, edh.ss$cell.type == "Naive CD4 T-cells"]),
    rowMedians(meth.norm[cl1, edh.ss$cell.type == "Memory CD4 T-cells"])
    )
  #cluster 2.
  t.test(
  rowMedians(meth.norm[cl2, edh.ss$cell.type == "Naive CD4 T-cells"]), 
  rowMedians(meth.norm[cl2, edh.ss$cell.type == "Memory CD4 T-cells"])
  )

#CpGs (naive CD8 vs effector CD8):
  #cluster 1.
  t.test(
    rowMedians(meth.norm[cl1, edh.ss$cell.type == "Naive CD8 T-cells"]), 
    rowMedians(meth.norm[cl1, edh.ss$cell.type == "Effector CD8 T-cells"])
    )
  #cluster 2.
  t.test(
    rowMedians(meth.norm[cl2, edh.ss$cell.type == "Naive CD8 T-cells"]), 
    rowMedians(meth.norm[cl2, edh.ss$cell.type == "Effector CD8 T-cells"])
    )

#CpGs (canonical NK vs adaptive NK):
  #cluster 1.
  t.test(
    rowMedians(meth.norm[cl1, edh.ss$cell.type == "Canonical NK-cells"]), 
    rowMedians(meth.norm[cl1, edh.ss$cell.type == "Adaptive NK-cells"])
    )
  #cluster 2.
  t.test(
    rowMedians(meth.norm[cl2, edh.ss$cell.type == "Canonical NK-cells"]), 
    rowMedians(meth.norm[cl2, edh.ss$cell.type == "Adaptive NK-cells"])
    )
```

#Use the clocks to predict age in the sorted celltypes.
```{r}
#Load DNAm values as betas.
load("Input/Input_10c_EDH_betas_noNA_and_normalized.RData")

#Put the data of the 4 clocks in the format the authors recommend.

#Load the beta-values.
load("Output/Output_04a_clock_beta_values.RData")
betas <- edh.noNA

# #Remove CpGs with missing data.
# idx <- is.na(edh.noNA[,1])
# edh.noNA <- edh.noNA[!idx,]
# edh.norm <- edh.norm[!idx,]
# dim(edh.noNA)
# dim(edh.norm)

#load("test/edh.data.expanded.RData")
#betas <- edh.betas
  
#Load the coefficients of all 4 clocks.
load("Input/Input_04a_clock_coefficients.RData")

horvath <- clock.coef$horvath
hannum <- clock.coef$hannum
zhang <- clock.coef$zhang
skinblood <- clock.coef$skinblood

#Hannum wants the DNA-methylation data to be in a format where samples are rows and probes are columns.
betas.hannum <- na.omit(betas[hannum[-1,]$Probe,])
betas.hannum <- t(betas.hannum)
betas.hannum[1:10,1:10]

#Horvath wants the DNA-methylation data to be in a format where probes are rows and samples are columns. Additionally, he uses the first column for the probe names (instead of the row names).
betas.horvath <- na.omit(betas[horvath[-1,]$Probe,])
probeIDs <- data.frame(probeID = rownames(betas.horvath))
datmat <- as.data.frame(betas.horvath)
betas.horvath <- cbind(probeIDs, datmat)
rownames(betas.horvath) <- 1:nrow(betas.horvath)
betas.horvath[1:10,1:10]

#Horvath (the author of the skinblood clock) wants the DNA-methylation data to be in a format where probes are rows and samples are columns. Additionally, he uses the first column for the probe names (instead of the row names).
idx <- na.omit(match(skinblood[-1,]$Probe, rownames(betas)))
betas.skinblood <- na.omit(betas[idx,])
probeIDs <- data.frame(probeID = rownames(betas.skinblood))
datmat <- as.data.frame(betas.skinblood)
betas.skinblood <- cbind(probeIDs, datmat)
rownames(betas.skinblood) <- 1:nrow(betas.skinblood)
betas.skinblood[1:10,1:10]

#Zhang wants the DNA-methylation data to be in a format where probes are rows and samples are columns.
#NB: Zhang uses normalized beta-values, instead of raw beta-values (like the other clocks). 
#Beta-values of all measured 450K-CpGs were normalized (using the "scale" function), so that each sample had a mean of 0 and an sd of 1.
#The normalized beta-values of these probes are loaded in here.
betas.zhang <- na.omit(edh.norm[zhang[-1,]$Probe,])
betas.zhang[1:10,1:10]

#Match the clock coefficients to match the data amtrices (meaning that CpGs with missing values will be removed).
hannum <- hannum[c(1, match(colnames(betas.hannum), hannum$Probe)),]
horvath <- horvath[c(1, match(betas.horvath$probeID, horvath$Probe)),]
skinblood <- skinblood[c(1, match(betas.skinblood$probeID, skinblood$Probe)),]
zhang <- zhang[c(1, match(rownames(betas.zhang), zhang$Probe)),]

#Next up, the age prediction of the 4 clocks will be tested.

#Clock 1: Hannum et al blood clock
#NB: this clock does not include an intercept, so an intercept of 0 was added.

#Load the data (IND * Probe, each row represents one individual, it should be "RAW BETA" DNA methylation value).
data <- t(betas.hannum)

#Get the coefficients of each probe.
coef <- hannum
colnames(coef) <- c("probe", "coef")
rownames(coef) <- coef$probe

intercept<-coef[1,2]
coef<-coef[-1,]
rownames(coef) <- coef$probe

#Do age prediction.
pred.hannum <- coef$coef%*%data+intercept


#Clock 2: Horvath pan-tissue clock
#NB: this clock was built using transformed age, instead of normal age. This is reflected in the "anti-trafo" function, which transforms the age from the transformed scale back into "normal" age.

#Function for transforming age.
adult.age1 <- 20
anti.trafo <- function(x,adult.age=adult.age1) {
  ifelse(x<0, (1+adult.age)*exp(x)-1, (1+adult.age)*x+adult.age)
}

data <- t(betas.horvath[, -1])
coef <- horvath
colnames(data) <- coef$Probe[-1]
data <- as.data.frame(data)

# Reality check: the following output should only contain numeric values.
# Further, the column names should be CpG identifiers (cg numbers), and the number of rows should equal the number of samples (Illumina arrays).
data[1:5, 1:5]
dim(data)

#Output DNAm age estimator for the pan-tissue clock.
pred.horvath <- as.numeric(anti.trafo(coef$Coefficient[1]+as.matrix(data)%*% as.numeric(coef$Coefficient[-1])))


#Clock 3: Horvath skin/blood clock.
# NB: this clock was built using transformed age, instead of normal age. 
# This is reflected in the "anti-trafo" function, which transforms the age from the transformed scale back into "normal" age.

#Function for transforming age.
adult.age1 <- 20
anti.trafo <- function(x,adult.age=adult.age1) {
  ifelse(x<0, (1+adult.age)*exp(x)-1, (1+adult.age)*x+adult.age)
}

data <- t(betas.skinblood[, -1])
coef <- skinblood

idx <- match(betas.skinblood$probeID, coef$Probe)
colnames(data) <- coef$Probe[idx]
data <- as.data.frame(data)

# Reality check: the following output should only contain numeric values.
# Further, the column names should be CpG identifiers (cg numbers), and the number of rows should equal the number of samples (Illumina arrays).
data[1:5, 1:5]
dim(data)

#Output/Output DNAm age estimator for the pan-tissue clock.
pred.skinblood <- as.numeric(anti.trafo(coef$Coefficient[1]+as.matrix(data)%*% as.numeric(coef$Coefficient[idx])))


#Clock 4: Zhang et al blood clock

#Load the data (Probe * IND, each column represents one individual. Data have already been normalized).
data <- betas.zhang

#Get the coefficients of each probe.
coef <- zhang
colnames(coef) <- c("probe", "coef")
rownames(coef) <- coef$probe

intercept <- coef[1,2]
coef <- coef[-1,]
rownames(coef) <- coef$probe

#Do age prediction.
pred.zhang <- coef$coef%*%data+intercept

pred <- data.frame(hannum = as.numeric(pred.hannum),
                   horvath = as.numeric(pred.horvath),
                   skinblood = as.numeric(pred.skinblood),
                   zhang = as.numeric(pred.zhang))
rownames(pred) <- colnames(pred.hannum)
head(pred)

#Test whether different cell types have different predicted ages.
head(edh.betas)
head(edh.ss)

#Prepare data for plotting.
pred <- pred[as.character(edh.ss$sample.id),]
pred$sample <- edh.ss$sample.id
pred$cell.type <- edh.ss$cell.type
pred$donor <- edh.ss$donor
pred$category <- edh.ss$category
levels(pred$category) <- c("CD4", "CD8", "NK")
pred$sample <- factor(pred$sample, levels = unique(pred$sample))
pred$donor <- factor(pred$donor)

head(pred, 10)
str(pred)

#Put the data in a format which ggplot understands.
library(reshape2)
pred.melt <- melt(pred, value.name = "predicted.age", variable.name = "clock", id.vars = c("sample", "cell.type", "donor", "category"))
levels(pred.melt$clock) <- c("Hannum Bld", "Horvath PT", "Horvath Skn/Bld", "Zhang Bld/Slv")
pred.melt <- pred.melt[order(pred.melt$cell.type),]
pred.melt$cell.type.short <- pred.melt$cell.type
levels(pred.melt$cell.type.short) <- c("Naive", "Memory",
                                   "Naive", "Effector", 
                                   "Canonical", "Adaptive")
pred.melt$category.long <- pred.melt$category
levels(pred.melt$category.long) <- paste0(levels(pred.melt$category.long), c(" T-cells", " T-cells", "-cells"))
head(pred.melt, 20)

#Plot the data (in 3 steps; set idx to 1, 2, or 3 for CD4s, CD8s, and NK cells, respectively.
fill.colors <- list(c("#ff6666", "#ee0000"),
                    c("#00dd00", "#009900"),
                    c("#66bbff", "#0066ee"))

for(idx in 1:3){
  ggplot(pred.melt[pred.melt$category == levels(pred.melt$category)[idx],], aes(x = cell.type.short, y = predicted.age, color = cell.type, group = donor)) +
  geom_line() +
  geom_point(size = 2) +
  # geom_text(aes(x = -3, y = (max(pred.melt$predicted.age)-2), label = difference), size = 6, hjust=0) +
  facet_grid(cols = vars(clock), rows = vars(category.long), scales = "fixed") +
  theme(axis.text.x = element_text(size = 9, hjust = 0.5), 
        axis.text.y = element_text(size = 10), axis.title = element_text(size = 14), 
        strip.text = element_text(size = 10), 
        legend.text = element_text(size = 12), legend.title = element_text(size = 14),
        plot.margin = unit(c(0.1, 0.1, 0.1, 1), "cm"),
        legend.position = "none"
        ) +
  scale_color_manual(values = fill.colors[[idx]]) +
  scale_y_continuous(limits = c(min(pred.melt$predicted.age), max(pred.melt$predicted.age)), breaks = c(0, 20, 40, 60, 80, 100, 120)) +
  scale_x_discrete(expand = c(0.25, 0.25))  +
  labs(x = "", y = "")

ggsave(file = sprintf("Output/Plot_10d.%s_EDH_age_prediction_%s.png", idx, levels(pred.melt$category)[idx]), width = 6, height = 1.8, dpi = 300)
}

#Make another plot for the scales and legend.
fill.colors <- c("#ff6666", "#ee0000", "#00dd00", "#009900", "#66bbff", "#0066ee")

ggplot(pred.melt, aes(x = cell.type, y = predicted.age, color = cell.type, group = donor)) +
  geom_line() +
  geom_point(size = 3) +
  facet_grid(rows = vars(clock), cols = vars(category),scales = "fixed") +
  theme(axis.text.x = element_text(size = 0, angle = 45, hjust = 1), 
        axis.text = element_text(size = 12), axis.title = element_text(size = 14), 
        strip.text = element_text(size = 12), 
        legend.text = element_text(size = 12), legend.title = element_text(size = 14),
        plot.margin = unit(c(0.1, 0.1, 0.1, 1), "cm")
        ) +
  scale_color_manual(values = fill.colors, name = "Cell type") +
  scale_y_continuous(limits = c(min(pred.melt$predicted.age), max(pred.melt$predicted.age)), breaks = c(0, 20, 40, 60, 80, 100)) +
  labs(x = "", y = "Predicted age (years)")

ggsave(file = "Output/Plot_10d.4_EDH_age_prediction_legend.png", width = 6, height = 6, dpi = 300)

#Prepare a dataframe containing the mean predicted ages in each cell type according to each clock.
mean.pred <- sapply(c("hannum", "horvath", "skinblood", "zhang"), function(x){
  sapply(levels(pred$cell.type), function(y){
    median(pred[(pred$cell.type == y), x])
  })
})
mean.pred

#Calculate the naive-activated difference per category.
pred.diff <- as.data.frame(t(mean.pred[c(2,4,6),] - mean.pred[c(1,3,5),]))
colnames(pred.diff) <- levels(pred$category)
apply(pred.diff, 2, mean)
pred.diff <- round(pred.diff, digits = 1)
clock.names <- c("Hannum Bld", "Horvath MT", "Horvath Skn/Bld", "Zhang Bld/Slv")
rownames(pred.diff) <- clock.names
pred.diff$clock <- clock.names
pred.diff

#Perform a paired t-test to test whether the naive-effector differences are statistically significant.
Naive.Effector.test <- function(category, clock){
  test1 <- pred[pred$category == category, clock]
  test2 <- pred[pred$category == category,"cell.type"]
  
  return(t.test(test1~test2, alternative = "less", paired = T))
}

#CD4
Naive.Effector.test(category = "CD4", clock = "hannum")$p.value
Naive.Effector.test(category = "CD4", clock = "horvath")$p.value
Naive.Effector.test(category = "CD4", clock = "skinblood")$p.value
Naive.Effector.test(category = "CD4", clock = "zhang")$p.value

#CD8
Naive.Effector.test(category = "CD8", clock = "hannum")$p.value
Naive.Effector.test(category = "CD8", clock = "horvath")$p.value
Naive.Effector.test(category = "CD8", clock = "skinblood")$p.value
Naive.Effector.test(category = "CD8", clock = "zhang")$p.value

#NK
Naive.Effector.test(category = "NK", clock = "hannum")$p.value
Naive.Effector.test(category = "NK", clock = "horvath")$p.value
Naive.Effector.test(category = "NK", clock = "skinblood")$p.value
Naive.Effector.test(category = "NK", clock = "zhang")$p.value
```
